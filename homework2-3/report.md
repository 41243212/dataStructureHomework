# 41243223

# 41243212

作業2-3
## 解題說明
**(a)：**  
計算合併階段的輸入時間 $t_{\text{input}}$，跟他相關的有，記憶體緩衝區配置，合併次數，磁碟存取與傳輸時間。

**(b)：**  
根據給出的參數，來計算不同 $k$ 值下的 $t_{\text{input}}$，並給出其與 $k$ 的關係圖，並判斷是否存在某個 $k$ 使得 $t_{\text{cpu}} \approx t_{\text{input}}$。
## 解題策略
### 練習 1(a)

1. **記憶體配置**  
   - 可用記憶體： $S$ records  
   - 緩衝區分配：分為 $2k + 2$ 個 buffer（ $2k$ 輸入緩衝區 + 2 輸出緩衝區）  
   - 每個 buffer 大小為 $B = \left\lfloor \frac{S}{2k + 2} \right\rfloor$

2. **合併次數**  
   - 初始有 $m$ 個 runs
   - 所需合併次數為：p = ceil(logₖ m)


3. **I/O 操作次數**  
   - 每 pass 處理資料量 $n$ ，每次 buffer 滿會觸發 I/O，總共約 $\lceil n / B \rceil$ 次

4. **單次 I/O 時間**  
   - 每次花費 $t_s + t_l + B \cdot t_r$

5. **總輸入時間公式**  
`t_input = p * ceil(n / B) * (t_s + t_l + B * t_r)`


---

### 練習 1(b)

**假設參數：**

| 參數     | 值                |
|----------|-------------------|
| $t_s$    | 0.08 秒           |
| $t_l$    | 0.02 秒           |
| $t_r$    | 0.001 秒 / record |
| $n$      | 200,000 records   |
| $m$      | 64 runs           |
| $S$      | 2000 records      |
| $t_{\text{cpu}}$ | 1000 秒     |



## 效能分析

| $k$ 值 | 合併層數 $p$ | buffer 大小 $B$ | 每層 I/O 次數 | 單次 I/O 時間 | $t_{\text{input}}$ |
|--------|---------------|------------------|----------------|----------------|--------------------|
| 2      | 6             | 333              | 601次            | 0.433 秒       | 1560.40 秒         |
| 4      | 3             | 200              | 1000次           | 0.300 秒       | 900.00 秒          |
| 8      | 2             | 111              | 1802次           | 0.211 秒       | 760.44 秒          |
| 16     | 2             | 58               | 3449次           | 0.158 秒       | 1089.88 秒         |
| 32     | 2             | 30               | 6667次           | 0.130 秒       | 1733.42 秒         |
| 64     | 1             | 15               | 13334次          | 0.115 秒       | 1533.41 秒         |

## 程式實作

## 測試與驗證

### 趨勢分析
- 當 $k$ 增大時，會影響到合併層數與緩衝區，其中合併層數 $p$ 縮小，但每層所需的 I/O 次數增加，因為每個 buffer 大小變小，導致需要更多次存取磁碟。

- 當 $k = 8$ 時， $t_{\text{input}}$ 達最低值 760.44 秒，代表此時合併次數與 I/O 數達到平衡。

- 當 $k = 16$ 時， $t_{\text{input}} \approx 1198.77$ ，最接近  $t_{\text{cpu}} = 1000$ ，符合題意所要求平衡的 k 值附近。

### 驗證 CPU 與 I/O 平衡點
- 我們希望找到一個 $k$，使得 $t_{\text{cpu}} \approx t_{\text{input}}$，而觀察結果顯示 $k=8$ 與 k=16 是最佳候選。

- 可依應用場景調整：若 CPU 運算稍慢，選 $k = 8$；若 CPU 快速，$k = 16$ 可達更高效能，如果$k = 2$，會導致合併層數過高導致要更久時間
## 結論
- 綜合考量後最佳的 k 值在 8 到 16 之間，其中 k = 8 時 $t_{\text{input}}$ 最小，k = 16 時更接近 $t_{\text{cpu}}$，依情況選擇。


## 申論及開發報告
### 開發過程
* 把外部排序的行為轉換成可量測的數學公式，要計算合併層次、buffer 配置、I/O 成本等。

* 程式計算：在程式構建後，觀察 $k$ 值與輸入時間的變化。

### 學習心得
實作過程讓我深入理解外部排序是如何排序的，其中記憶體配置的 trade-off，和I/O 操作讓我更理解了。
